<?php

const UOFM_AGGREGATE_PDFS_VALID_CMODELS_MULTI = ['islandora:bookCModel', 'islandora:newspaperIssueCModel'];
const UOFM_AGGREGATE_PDFS_VALID_CMODELS_SINGLE = ['islandora:pageCModel', 'islandora:newspaperPageCModel'];

/**
 * Custom queue builder.
 * @param string $pid
 *   The PID
 * @return array
 *   Array with both PID and skip_pages values.
 */
function uofm_aggregate_pdfs_queue_builder(string $pid) {
  $skip = !is_null(drush_get_option('skip_pages', NULL));
  return [
    'pid' => $pid,
    'skip_pages' => $skip,
  ];
}

/**
 * Generate PDF for a paged content object, which might also involve processing all the pages.
 * @param array $data
 *   An array with keys PID and skip_pages from the custom queue builder.
 * @return bool
 *   False if an semi-handable error occurred and we should try again, True if it worked or completely failed.
 * @see uofm_aggregate_pdfs_queue_builder
 */
function uofm_aggregate_pdfs_worker(array $data) {
  module_load_include('inc', 'islandora', 'includes/utilities');
  $paged_content_pid = $data['pid'];
  $skip_pages = $data['skip_pages'];
  if (islandora_is_valid_pid($paged_content_pid)) {
    $object = islandora_object_load($paged_content_pid);
    if ($object !== FALSE) {
      // We only work on books and newspaper so far.
      if (count(array_intersect(UOFM_AGGREGATE_PDFS_VALID_CMODELS_MULTI, $object->models)) > 0) {
        $return = uofm_aggregate_pdfs_do_paged_content($object, $skip_pages);
      }
      elseif (count(array_intersect(UOFM_AGGREGATE_PDFS_VALID_CMODELS_SINGLE, $object->models)) > 0) {
        // If we are doing a single page, then we never skip it.
        $return = uofm_aggregate_pdfs_do_page($object, FALSE);
      }
      else {
        drush_log("We can only operate on objects of type islandora:bookCModel, islandora:newspaperIssueCModel, " .
        "islandora:pageCModel and islandora:newspaperPageCModel");
        return TRUE;
      }
      // Delete any files generated by this process.
      foreach ($return['files'] as $file) {
        if (!is_bool($file) && file_exists($file)) {
          file_unmanaged_delete($file);
        }
      }
      return $return['state'];
    }
    else {
      drush_log("Unable to load object for pid $paged_content_pid", "error");
    }
  }
  else {
    drush_log("PID $paged_content_pid is not valid", "error");
    return TRUE;
  }
  return FALSE;
}

/**
 * Generate the PDF for a paged content object, which might also involve processing all the pages.
 * @param \AbstractObject $paged_content
 *   The paged content object.
 * @return array
 *  Associative array with keys: state = return state and files = generated by this process.
 */
function uofm_aggregate_pdfs_do_paged_content(AbstractObject $paged_content, bool $skip_pages) {
    module_load_include('inc', 'islandora_paged_content', 'includes/utilities');
    $pdf_file = drupal_realpath("temporary://{$paged_content->id}_PDF.pdf");
    $pages = array_keys(islandora_paged_content_get_pages($paged_content));
    $page_count = count($pages);
    $page_files = [];
    foreach ($pages as $page) {
      $object = islandora_object_load($page);
      if ($object !== FALSE) {
        $return = uofm_aggregate_pdfs_do_page($object, $skip_pages);
        if ($return['state'] === FALSE) {
          drush_log("Unable to generate a PDF file for $page", "error");
        }
        else {
          // No error so take the first filename
          $page_files[] = reset($return['files']);
        }
      }
      else {
        // We don't add anything to $page_files to make the page count wrong.
        drush_log("Unable to load page object with pid $page", "error");
      }
    }
    $real_count = count($page_files);
    if ($real_count !== $page_count) {
      // We did not make all the pages we need.
      drush_log("Page count $real_count does not match expected $page_count. Exiting without generating consolidated PDF", "error");
      return [
        'state' => FALSE,
        'files' => $page_files,
      ];
    }
    // Start the loop below so we always increment before processing.
    $progress = -10;
    // Process return values so we can halt if some of the appending fails.
    $ret = TRUE;
    while ($progress < $page_count && $ret === TRUE) {
      $progress += 10;
      $current_pages = array_slice($page_files, $progress, 10);
      if ($progress !== 0) {
        $ret = islandora_paged_content_pdf_append($pdf_file, $current_pages);
      }
      else {
        $ret = islandora_paged_content_pdf_combine($current_pages, $pdf_file);
      }
    }
    if ($ret === TRUE) {
      // We completed and still returned TRUE, so the PDF is valid.
      islandora_paged_content_update_datastream($paged_content, $pdf_file, 'PDF');
    }
    // return a list of all page files and the consolidated PDF
    $page_files[] = $pdf_file;
    return [
      'state' => $ret,
      'files' => $page_files,
    ];
}

/**
 * Generate a PDF for a page of the paged content object.
 * @param \AbstractObject $page
 *   The page object.
 * @param bool $skip_pages
 *   Whether to skip regenerating pages that already have a PDF.
 * @return array
 *   Associative array with keys: state = return state and files = the filename generated by this process.
 */
function uofm_aggregate_pdfs_do_page(AbstractObject $page, bool $skip_pages) {
  $options = array(
    '-density' => 300,
    '-compress' => 'LZW',
  );
  if ($skip_pages === FALSE || !isset($page['PDF'])) {
    $pdf_file = islandora_paged_content_page_derive_pdf($page, $options);
    if ($pdf_file !== FALSE) {
      // Only update if the PDF was correctly derived.
      islandora_paged_content_update_datastream($page, $pdf_file, 'PDF');
    }
    $output = [
      'state' => ($pdf_file !== FALSE),
      'files' => [$pdf_file],
    ];
  }
  else {
    // There is already a PDF and we are skipping, so just get the existing PDF datastream.
    $base_name = "page_{$page->id}.pdf";
    $base_name = str_replace(':', '-', $base_name);
    $pdf_file = file_create_filename($base_name, 'temporary://');
    $ret = $page['PDF']->getContent($pdf_file);
    $pdf_file = drupal_realpath($pdf_file);
    $output = [
      'state' => $ret,
      'files' => [$pdf_file],
    ];
  }
  return $output;
}
